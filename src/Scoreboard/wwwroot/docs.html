<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scoreboard — Documentation</title>

    <!-- highlight.js -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/json.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/csharp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/bash.min.js"></script>

    <!-- marked.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/12.0.1/marked.min.js"></script>

    <!-- mermaid -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.9.0/mermaid.min.js"></script>

    <style>
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background: #000;
            color: #e0e0e0;
            line-height: 1.6;
            display: flex;
            min-height: 100vh;
        }

        /* ── Sidebar ── */
        nav {
            position: fixed;
            top: 0;
            left: 0;
            width: 260px;
            height: 100vh;
            background: #111;
            border-right: 1px solid #333;
            overflow-y: auto;
            padding: 20px 0;
            z-index: 10;
        }

        nav .nav-title {
            padding: 0 20px 16px;
            font-size: 15px;
            font-weight: 700;
            color: #69db7c;
            border-bottom: 1px solid #333;
            margin-bottom: 12px;
        }

        nav a {
            display: block;
            padding: 6px 20px;
            color: #aaa;
            text-decoration: none;
            font-size: 13px;
            transition: color 0.15s, background 0.15s;
        }

        nav a:hover, nav a.active {
            color: #69db7c;
            background: #1a1a1a;
        }

        nav a.sub {
            padding-left: 36px;
            font-size: 12px;
            color: #777;
        }

        nav a.sub:hover, nav a.sub.active {
            color: #69db7c;
        }

        /* ── Main content ── */
        main {
            margin-left: 260px;
            flex: 1;
            max-width: 900px;
            padding: 40px 48px 80px;
        }

        /* ── Typography ── */
        h1 { font-size: 28px; color: #69db7c; margin: 0 0 8px; }
        h2 { font-size: 22px; color: #69db7c; margin: 48px 0 16px; padding-bottom: 6px; border-bottom: 1px solid #333; }
        h3 { font-size: 17px; color: #ccc; margin: 32px 0 12px; }
        h4 { font-size: 14px; color: #aaa; margin: 24px 0 8px; }
        p { margin: 0 0 12px; }
        ul, ol { margin: 0 0 12px; padding-left: 24px; }
        li { margin-bottom: 4px; }
        strong { color: #fff; }
        code { background: #1e1e1e; padding: 2px 6px; border-radius: 3px; font-size: 13px; color: #69db7c; }
        a { color: #69db7c; }

        pre {
            background: #1e1e1e;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 16px;
            overflow-x: auto;
            margin: 0 0 16px;
        }

        pre code {
            background: none;
            padding: 0;
            color: inherit;
        }

        /* ── Tables ── */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 0 0 16px;
            font-size: 13px;
        }

        th, td {
            text-align: left;
            padding: 8px 12px;
            border: 1px solid #333;
        }

        th { background: #1a1a1a; color: #69db7c; font-weight: 600; }
        td { background: #111; }

        /* ── Mermaid ── */
        .mermaid {
            background: #1e1e1e;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 20px;
            margin: 0 0 16px;
            text-align: center;
        }

        /* ── Blockquotes ── */
        blockquote {
            border-left: 3px solid #69db7c;
            padding: 8px 16px;
            margin: 0 0 16px;
            background: #0d1f0d;
            border-radius: 0 6px 6px 0;
        }

        blockquote p:last-child { margin-bottom: 0; }

        /* ── Mobile ── */
        @media (max-width: 860px) {
            nav { display: none; }
            main { margin-left: 0; padding: 24px 20px 60px; }
        }
    </style>
</head>
<body>
    <nav id="sidebar"></nav>
    <main id="content"></main>

    <script id="doc-source" type="text/template">
# Scoreboard Documentation

A basketball scoreboard single-page app packaged as a WebModule (`SharedTools.Scoreboard`). The frontend runs a **game instance** — a self-contained unit of scores, rosters, timers, and event logs. The backend's primary job is acting as a **key dispenser** for Azure Blob Storage; it stays out of the live data path.

## System Overview

### Architecture

```mermaid
graph LR
    Host["ASP.NET Host"] -->|loads| Module["Scoreboard Module"]
    Module -->|serves| SPA["SPA (app.js)"]
    SPA -->|POST /api/upload-history| API["Server API"]
    API -->|writes| Blob["Azure Blob Storage"]
    SPA -->|GET /api/groups/join| API
    API -->|returns SAS URLs| SPA
    SPA -->|direct PUT/GET via SAS| Blob
```

The host loads `SharedTools.Scoreboard` as a NuGet-packaged WebModule. The SPA is served as an embedded resource at `/Scoreboard/`. Game state flows through three paths:

1. **localStorage** — immediate, every change
2. **Direct-to-Blob** — SPA writes game state and event logs directly via SAS URLs (5s debounce)
3. **Server POST** — score history uploaded to `/api/upload-history` (10s debounce), server writes blob

The server never sits in the hot path during a game. It creates groups, dispenses SAS tokens, and stores score-history snapshots.

### Module Contract

The module implements `IApplicationPartModule`:

- **ConfigureServices** — registers `BlobContainerClient`, `IDefaultPlayersService`, `IGroupService`
- **Configure** — maps all routes under `/Scoreboard/` prefix
- **Static assets** — embedded in the DLL under `wwwroot/`, served at `/_content/Scoreboard/`

## Components

### Class Diagram

```mermaid
graph TD
    App["ScoreboardApp"] --> Timer
    App --> Teams
    App --> Players
    App --> Settings
    App --> UI
    App --> BlobSync
    App --> Weekly["WeeklySetup"]
```

`ScoreboardApp` is the central orchestrator. It owns the game instance and all component references. Components operate on the shared app state.

### Component Reference

| Class | Role | Key State | Key Methods |
|-------|------|-----------|-------------|
| **ScoreboardApp** | Orchestrator, owns game instance | `periodScores[]`, `scoreHistory[]`, `playersList[]` | `recordScoreChange()`, `captureScore()`, `syncGameState()`, `syncEventLog()` |
| **Timer** | Countdown clock | `timeLeft`, `isRunning`, `lastTap` | `startStop()`, `reset()`, `handleTimerTap()`, `playAlarm()` |
| **Teams** | Score and name tracking | `team1Points`, `team2Points` | `incrementScore()`, `decrementScore()`, `setTeamNames()` |
| **Players** | Roster management | (uses `app.playersList`) | `addPlayer()`, `incrementPlayerPoints()`, `updatePlayersDisplay()` |
| **Settings** | Configuration panel | (DOM element refs) | `toggle()`, `updateGroupUI()`, `handleJoinGroup()`, `handleCreateGroup()` |
| **UI** | Display updates | (DOM element refs) | `toggleFullscreen()`, `updateScoreHistory()`, `updateScoreFontSize()` |
| **BlobSync** | Azure Blob I/O + group state | `groupId`, `readUrl`, `writeUrl`, `code` | `join()`, `upload()`, `download()`, `debouncedUpload()` |
| **WeeklySetup** | Weekly game configuration | `available`, `teams`, `forced` | `randomizeTeams()`, `publish()`, `applyToScoreboard()` |

## Scoreboard Engine

### Game Instance

A game instance is the core data unit. It contains:

- Two teams with names and scores
- A player roster with per-player points
- Timer configuration (minutes per period)
- Period scores array (captured on timer expiry)
- An event log of every score change

The frontend runs whatever game instance it's given. When connected to a group, the instance syncs to Azure Blob Storage so multiple devices see the same state.

### Timer

The timer counts down from a configurable duration (1–60 minutes, default 15).

**Interaction:**
- **Tap** — start or stop the countdown
- **Double-tap** (within 300ms) — reset to configured duration
- Detection via timestamp comparison in `handleTimerTap()`

**On expiry (timeLeft reaches 0):**
1. Stop the interval
2. Capture the period score (`"team1Score - team2Score"` string pushed to `periodScores[]`)
3. Play the buzzer audio
4. Blink the timer background red 5 times at 250ms intervals
5. Auto-reset to the configured duration

### Scoring

**Team scores:**
- **Click** the score display → increment by 1
- **Long-press** (800ms touch) → decrement by 1 (floor at 0)

**Player scoring:**
- Click a player name in the on-screen team list → increments both the player's individual points **and** their team's score
- In the Players panel table: **+/−** buttons adjust player points and team score together

Every score change calls `app.recordScoreChange(teamNumber, isIncrement, playerName)` which creates a history entry and triggers all three persistence paths.

### Periods

The `periodScores[]` array stores period-ending snapshots as strings like `"24 - 18"`.

- Captured automatically when the timer expires
- Displayed below the timer as `contentEditable` spans (allowing manual correction)
- Included in the game state synced to blob
- "Reset History" in Settings clears both `periodScores` and `scoreHistory`

## Events & Data Flow

### Score Change Sequence

```mermaid
sequenceDiagram
    participant User
    participant Teams/Players
    participant App as ScoreboardApp
    participant LS as localStorage
    participant Blob as Azure Blob (direct)
    participant Server as Server API

    User->>Teams/Players: Click score / player
    Teams/Players->>App: recordScoreChange()
    App->>LS: Save scoreHistory (immediate)
    App->>Blob: debouncedUpload game state (5s)
    App->>Blob: debouncedUpload event log (5s)
    App->>Server: POST /api/upload-history (10s debounce)
    Server->>Blob: Write score-history-{timestamp}.json
```

### Three Upload Paths

| Path | Target | Trigger | Debounce |
|------|--------|---------|----------|
| **localStorage** | Browser | Every score change | None (immediate) |
| **BlobSync (game state)** | `games/{gameId}.json` | Every score change | 5 seconds |
| **BlobSync (event log)** | `games/{gameId}-events.json` | Every score change | 5 seconds |
| **Server upload** | `score-history-{timestamp}.json` | Every score change | 10 seconds |

### Score History Entry Shape

```json
{
  "timestamp": "1/31/2026, 3:45:30 PM",
  "timerCurrent": 450,
  "timerStart": 900,
  "teamNumber": 1,
  "action": "increment",
  "playerName": "Alice",
  "team1Score": 42,
  "team2Score": 38,
  "team1Name": "WHITE",
  "team2Name": "BLACK"
}
```

`playerName` is `undefined` when the team score element is clicked directly (not via a player).

## UI Features

### Main View

The scoreboard layout from top to bottom:

- **Scores row** — large clickable score displays with team names (`contentEditable`) above them. Player lists flank the scores on each side.
- **Timer** — large countdown display below the scores. Tap to start/stop, double-tap to reset.
- **Period history** — row of editable period score spans below the timer.
- **Control buttons** — fixed bottom-right: Game Setup (W), Players, Settings, Fullscreen.

### Side Panels

Three 510px-wide panels toggle from the control buttons. Clicking outside an open panel closes it.

**Players panel:**
- Management table with columns: Name, Team (select), Active (checkbox), Points (+/−), Remove (X)
- Add player input with Enter key support
- Export (clipboard), Import (paste JSON), Load Defaults buttons

**Settings panel:**
- Timer duration input (1–60 minutes) with Set Timer button
- Team name inputs (synced bidirectionally with main display)
- Score decrement (−1) buttons per team
- Reset Scores, Reset History, Test Buzzer, Test Timer End buttons
- Score font size slider (5–15 rem)
- Timer font size slider (6–20 rem)
- Keep Screen On checkbox (Wake Lock API)
- Group management section (join/create/share/leave)
- Manage Default Players link
- Blob Storage test connection button

**Game Setup (Weekly) panel:**
- Date picker (defaults to next Friday)
- Player roster with: availability checkbox, team pin select (—/Pin W/Pin B), team badge
- Randomize Teams — Fisher-Yates shuffle respecting forced pins, distributes evenly
- Publish — uploads week config to blob
- Apply to Board — assigns teams, resets scores, closes panel

### Fullscreen & Wake Lock

- **Fullscreen** — cross-browser toggle via `requestFullscreen` API
- **Wake Lock** — prevents device sleep via `navigator.wakeLock`. Re-acquired on visibility change. Persisted to localStorage.
- **Font sizes** — persisted to localStorage, applied on load

## Storage

### localStorage Keys

| Key | Type | Description |
|-----|------|-------------|
| `groupCode` | string | Current group code for auto-rejoin |
| `scoreHistory` | JSON array | Detailed score change event log |
| `scoreFontSize` | string | Score display font size in rem |
| `timerFontSize` | string | Timer display font size in rem |
| `keepScreenOn` | `"true"` / `"false"` | Wake lock preference |
| `lastUploadAttempt` | JSON object | `{timestamp, success, error?, filename?}` |
| `playersList` | JSON array | Current player roster |

### Azure Blob Layout

```text
container/
├── _groups/{groupId}.json              # Group metadata (server-managed)
├── {groupId}/
│   ├── roster.json                     # Player roster
│   ├── week/{date}.json                # Weekly game config
│   ├── games/{gameId}.json             # Live game state
│   └── games/{gameId}-events.json      # Score event log
└── score-history-{timestamp}.json      # Server-uploaded snapshots
```

**Game state** (`games/{gameId}.json`):

```json
{
  "id": "game-2026-01-31",
  "weekDate": "2026-01-31",
  "team1": { "name": "WHITE", "score": 42 },
  "team2": { "name": "BLACK", "score": 38 },
  "period": 2,
  "periodScores": ["24 - 18"],
  "timerMinutes": 15,
  "players": []
}
```

**Event log** (`games/{gameId}-events.json`):

```json
{
  "events": [
    {
      "timestamp": "1/31/2026, 3:45:30 PM",
      "type": "score",
      "teamNumber": 1,
      "playerName": "Alice",
      "action": "increment",
      "scores": { "team1": 42, "team2": 38 },
      "team1Name": "WHITE",
      "team2Name": "BLACK",
      "timerCurrent": 450
    }
  ]
}
```

### Sync Behavior

`BlobSync.debouncedUpload(path, data, delayMs)` uses path-keyed timeouts — each blob path gets its own debounce timer. If a new change arrives before the timer fires, it resets.

On **403** responses (expired SAS), BlobSync automatically calls `_refreshSas()` to get new tokens from the server, then retries the original operation once.

## Groups & Sharing

### Concept

Groups are access containers for shared scoreboard state. A group has:

- One **admin code** (8-char uppercase) — full control
- Multiple **member codes** (6-char lowercase) — read/write game data

The code is your key. Enter it to get SAS tokens for direct blob access.

### Code Charsets

| Type | Length | Characters | Excluded |
|------|--------|------------|----------|
| Admin | 8 | `ABCDEFGHJKLMNPQRSTUVWXYZ23456789` | I, O, 0, 1 |
| Member | 6 | `abcdefghjkmnpqrstuvwxyz23456789` | i, l, o, 0, 1 |

Ambiguous characters are excluded to prevent confusion when sharing codes verbally.

### Flow

```mermaid
sequenceDiagram
    participant Admin
    participant Server
    participant Blob as Azure Blob
    participant Member

    Admin->>Server: POST /api/groups {name}
    Server-->>Admin: {groupId, adminCode}
    Admin->>Server: GET /api/groups/join?code=ADMINCODE
    Server-->>Admin: {groupId, sasUrls}
    Admin->>Blob: Upload roster, game state

    Admin->>Server: POST /api/groups/{id}/members {label}
    Server-->>Admin: {memberCode}
    Admin-->>Member: Share link with code

    Member->>Server: GET /api/groups/join?code=membercode
    Server-->>Member: {groupId, sasUrls}
    Member->>Blob: Read/write game state directly
```

### Auto-Join

On page load, the SPA checks for a group code in this order:
1. URL query parameter `?code=XXX`
2. URL hash `#XXX`
3. localStorage `groupCode`

If found, it automatically joins and loads group data (roster, weekly config, active game).

### SAS Tokens

- **Expiry**: 3 hours from generation
- **Permissions**: Read + List always; Write + Create for all members (admin and member codes both get write access)
- **Refresh**: Transparent — on 403, BlobSync calls `/api/groups/{id}/sas/refresh?code=X` and retries

### Permissions

- **Admin**: create group, add/revoke members, read/write all data
- **Members**: read/write game data, cannot manage membership

## API Reference

### POST `/Scoreboard/api/groups`

Create a new group.

**Request body:**
```json
{ "name": "Friday Hoops" }
```

**Response (201):**
```json
{
  "groupId": "uuid",
  "name": "Friday Hoops",
  "adminCode": "ABC2DEFG"
}
```

**Errors:** `400` — name is required

---

### GET `/Scoreboard/api/groups/join?code=X`

Join a group using an admin or member code. Returns SAS URLs for direct blob access.

**Response (200):**
```json
{
  "groupId": "uuid",
  "groupName": "Friday Hoops",
  "isAdmin": true,
  "sasUrls": {
    "readUrl": "https://...?sv=...&sig=...",
    "writeUrl": "https://...?sv=...&sig=..."
  }
}
```

**Errors:** `400` — code required, `404` — invalid code

---

### POST `/Scoreboard/api/groups/{id}/members?adminCode=X`

Add a member to a group (admin only).

**Request body:**
```json
{ "label": "Player 1" }
```

**Response (201):**
```json
{ "code": "abc2de", "label": "Player 1" }
```

**Errors:** `400` — admin code or label required, `403` — invalid admin code, `404` — group not found

---

### DELETE `/Scoreboard/api/groups/{id}/members/{code}?adminCode=X`

Revoke a member's access (admin only).

**Response:** `204` No Content

**Errors:** `400` — admin code required, `403` — invalid admin code, `404` — group or member not found

---

### GET `/Scoreboard/api/groups/{id}/sas/refresh?code=X`

Refresh SAS tokens. Works with both admin and member codes.

**Response (200):**
```json
{
  "readUrl": "https://...?sv=...&sig=...",
  "writeUrl": "https://...?sv=...&sig=..."
}
```

**Errors:** `400` — code required, `403` — invalid code, `404` — group not found

---

### POST `/Scoreboard/api/upload-history`

Upload score history snapshot. Server writes to blob as `score-history-{timestamp}.json`.

**Request body:** JSON array of score history entries (max 500 KB).

**Response (200):**
```json
{ "filename": "score-history-2026-01-31-15-45-30.json" }
```

**Errors:** `400` — invalid/empty body or not valid JSON, `500` — upload failure

---

### GET `/Scoreboard/api/test-blob-connection`

Test blob storage connectivity by writing a test file.

**Response (200):**
```json
{ "message": "Connection to blob storage successful!" }
```

**Errors:** `500` — connection failure

---

### GET `/Scoreboard/api/default-players`

Get the default player roster.

**Response (200):** Array of player objects:
```json
[
  { "id": 1742075931014, "name": "Alice", "team": "1", "active": true, "points": 0 }
]
```
    </script>

    <script>
        // ── Mermaid init ──
        mermaid.initialize({
            startOnLoad: false,
            theme: 'dark',
            themeVariables: {
                primaryColor: '#1a3a1a',
                primaryTextColor: '#e0e0e0',
                primaryBorderColor: '#69db7c',
                lineColor: '#69db7c',
                secondaryColor: '#1e1e1e',
                tertiaryColor: '#111',
                fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif'
            }
        });

        // ── Custom marked renderer ──
        const renderer = new marked.Renderer();

        renderer.code = function ({ text, lang }) {
            if (lang === 'mermaid') {
                return `<div class="mermaid">${text}</div>`;
            }
            const highlighted = lang && hljs.getLanguage(lang)
                ? hljs.highlight(text, { language: lang }).value
                : hljs.highlightAuto(text).value;
            return `<pre><code class="hljs language-${lang || ''}">${highlighted}</code></pre>`;
        };

        renderer.heading = function ({ text, depth }) {
            const id = text.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '');
            return `<h${depth} id="${id}">${text}</h${depth}>`;
        };

        marked.setOptions({ renderer, breaks: false, gfm: true });

        // ── Render content ──
        const md = document.getElementById('doc-source').textContent;
        document.getElementById('content').innerHTML = marked.parse(md);

        // ── Build sidebar from headings ──
        const sidebar = document.getElementById('sidebar');
        const headings = document.querySelectorAll('main h1, main h2, main h3');
        let navHtml = '<div class="nav-title">Scoreboard Docs</div>';

        headings.forEach(h => {
            const level = parseInt(h.tagName[1]);
            if (level === 1) return; // skip the page title
            const cls = level === 3 ? ' class="sub"' : '';
            navHtml += `<a href="#${h.id}"${cls}>${h.textContent}</a>`;
        });

        sidebar.innerHTML = navHtml;

        // ── Highlight active nav on scroll ──
        const navLinks = sidebar.querySelectorAll('a');
        const headingEls = Array.from(headings).filter(h => h.tagName !== 'H1');

        function updateActive() {
            let current = '';
            for (const h of headingEls) {
                if (h.getBoundingClientRect().top <= 80) current = h.id;
            }
            navLinks.forEach(a => {
                a.classList.toggle('active', a.getAttribute('href') === '#' + current);
            });
        }

        window.addEventListener('scroll', updateActive, { passive: true });
        updateActive();

        // ── Render mermaid diagrams ──
        mermaid.run({ querySelector: '.mermaid' });
    </script>
</body>
</html>
